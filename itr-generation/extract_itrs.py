import tensorflow as tf 
import numpy as np 

from datetime import datetime
import os

import itr_matcher

import argparse
parser = argparse.ArgumentParser(description='Generate IADs from input files')
#required command line args
parser.add_argument('iad_dir', help='The input file')
parser.add_argument('pad_length', type=int, help='The length to pad the file')

parser.add_argument('--prefix', nargs='?', default="complete", help='the prefix to place infront of finished files <prefix>_<layer>.npz')
parser.add_argument('--dst_directory', nargs='?', default='generated_itrs/', help='where the IADs should be stored')
parser.add_argument('--gpu_memory', nargs='?', type=float, default=0.5, help='where the IADs should be stored')



FLAGS = parser.parse_args()

'''
#0 - empty
#1 - br
#2 - bl
#3 - b
#4 - tr
#5 - r
#6 - tr, bl
#7 - r, bl
#8 - tl
#9 - tl, br
#10 - l
#11 - l, br
#12 - t
#13 - r, tl
#14 - l, tr
#15 - full

CORE_FILTERS_13 = {
		'meets': np.array([[9]]),
		'metBy': np.array([[6]]),
		'starts': np.array([[5,11]]),
		'startedBy': np.array([[5,14]]),
		'finishes': np.array([[7,10]]),
		'finishedBy': np.array([[13,10]]),
		'overlaps': np.array([[13,11]]),
		'overlapedBy': np.array([[7,14]]),
		'during': np.array([[7,11]]),
		'contains': np.array([[13,14]]),
		'before': np.array([[8,1]]),
		'after': np.array([[2,4]]),
		'equals': np.array([[5,10]])
	}
'''

write_file,run_code = 0, 0

############################
# Pairwise Combinations
############################

def pairwise_gather(input_var):
	'''
	Generates a pairwise combination of all the rows in the input tensor
	'''
	num_features = input_var.get_shape()[0]

	# get all unique pairwise combinations of two features
	indices = []
	for i in range(num_features):
		for j in range(i, num_features):
			if(i != j):
				indices.append([[i], [j]])

	print("input_var:", input_var, input_var.get_shape())
	return tf.gather_nd(input_var, indices, name="pairwise_gather")

############################
# Convolution
############################

def permute_filter_combinations(shared_array, array, cur_depth):
	'''
	Recursively get all possible filter combinations of -1 and 1 for a filter shape
	'''
	if(cur_depth == len(array)):
		shared_array.append(array)
	else:
		for value in [-1,1]:
			array[cur_depth] = value
			permute_filter_combinations(shared_array, array[:], cur_depth+1)

def get_variables(filter_width):
	'''
	Generate the fixed filters used in the convolution
	'''
	filters = []
	permute_filter_combinations(filters, [1]*(2*filter_width), 0)
	filters = np.array(filters).reshape((-1, 2, filter_width))

	# modify the shape of the filters to allow convolution by tensorflow
	filters = np.expand_dims(filters, axis = 0)
	filters = np.transpose(filters, (2,3, 0, 1))
	filters = tf.cast(tf.constant(filters),tf.float32)
	return filters

def generate_pairwise_projections(input_ph, filter_width=2):
	'''
	Generate the projection of filters for each of the pairwise combinations
	of rows in the IAD. This involves two steps: 1) the pairwise seprataion 
	of features and 2) the convolution of each pairwise combination with a 
	specific set of fixed filters (known as moments). The best moment at each
	time instance is then projected into a 1-D array for the pairwise combination
		- placeholders: dict, placeholders for the convolution 
				(see get_placeholders function)
		- filter_width: int, default (2) the width of the fixed filters
	'''

	# get pairwise combination of IAD features
	pw = pairwise_gather(input_ph)
	
	# pad the beginning and ending of each IAD with -1 values to ensure that 
	# specific core moments can be found
	pw = tf.pad(pw, tf.constant([[0,0], [0,0], [1,1]]), "CONSTANT", constant_values = -1)
	
	#reshape combinations for subsequent operations
	pw = tf.expand_dims(pw, axis = 0)
	pw = tf.transpose(pw, perm=[1,2,3,0])

	#convolve
	variables = get_variables(filter_width)
	conv0 = tf.nn.conv2d(pw, variables, strides=[1,1,1,1], padding='VALID', name="conv2d_op")
	conv0 = tf.squeeze(conv0, name="squeeze_op", axis=1)

	#collapse data
	return tf.argmax(conv0, axis = 2)

############################
# Collapse and Count
############################

def extract_itrs(projections):
	#global write_file, run_code
	'''
	Identify the IADs present in the pairwise projections generated by the 
	"generate_pairwise_projections" function. This is done by manipulating 
	the data so that it can be passed into a function that runs in C++
		- projections: tensor, a tensor containing the projections for each 
				pairwise combination of features in the IAD
	'''

	# get the properties of the input
	num_pw_combinations = projections.shape[0]
	num_time_instances = projections.shape[1]
	num_itrs = 13

	# write information to file to be read in C++
	projections = projections.astype(np.int64)

	# prepare output array
	itr_counts = [0]*(num_pw_combinations * num_itrs)

	# extract ITRs using C++
	itr_matcher.thread(projections, num_pw_combinations, num_time_instances, itr_counts)

	# reshape the resultant array into a reasonable format
	return np.array(itr_counts).reshape((num_pw_combinations, num_itrs))

############################
# Main
############################

def parse_iadlist(iad_dir, prefix):
    '''Opena dn parse a .iadlist file'''

    iadlist_filename = os.path.join(iad_dir, prefix+".iadlist")

    try:
        ifile = open (iadlist_filename, 'r')
    except:
        print("File doesn't exist: "+ iadlist_filename)
        sys.exit(1)
    
    iad_groups = []

    line = ifile.readline()
    while(len(line) > 0):
        filename_group = [os.path.join(iad_dir, f) for f in line.split()]
        iad_groups.append(filename_group)
        line = ifile.readline()
    return iad_groups

def extract_itrs_from_filename_group(dataset, layer, prefix):
	data, labels, lengths = [],[],[]
	for file_group in dataset:

		f = np.load(os.path.join(input_dir, file_group[layer]))
		d, l, z = f["data"], f["label"], f["length"]

		# clip the data for values outside of the expected range
		iad = np.clip(d, 0.0, 1.0)

		# scale the data to be between -1 and 1
		iad *= 2
		iad -= 1

		if (FLAGS.pad_length > z):
			iad = np.pad(iad, [[0,0],[0,FLAGS.pad_length-z]], 'constant', constant_values=0)
		else:
			iad = iad[:,:FLAGS.pad_length]

		data.append(iad)
		labels.append(l)
		lengths.append(z)

	data = np.array(data)
	labels = np.array(labels)
	lengths = np.array(lengths)

	###############################
	# Extract ITRs
	###############################

	# get the pairwise projection (one dimensional representations of the data)
	#print (data.shape)
	ph = tf.placeholder(tf.float32, shape=(data.shape[1],FLAGS.pad_length),name="input_ph")
	itr_extractor = generate_pairwise_projections(ph)

	# prevent TF from consuming entire GPU
	gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=FLAGS.gpu_memory)

	with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) as sess:
		sess.run(tf.local_variables_initializer())
		sess.run(tf.global_variables_initializer())

		# get the pairwise projection and then extract the ITRs
		itrs = []
		for i in range(len(data)):
			print("Processing file {:6d}/{:6d}".format(i, len(data)))
			
			pairwise_projections = sess.run(itr_extractor, feed_dict = {ph: data[i]})
			itrs.append(extract_itrs(pairwise_projections[:, :lengths[i]+1]))

		#stack ITRs and save
		filename = os.path.join(FLAGS.dst_directory, prefix)
		if (os.path.exists(filename+".npz")):
			filename += "_"+datetime.now().strftime("%m-%d-%Y_%H-%M-%S")
		print("saving ITRs together to file: {0}".format(filename))
		np.savez(filename+".npz", data=np.array(itrs), label=labels)

def main(input_dir):
	#provide filenames and generate and save the ITRs into a nump array
	print("opening directory: "+input_dir)

	train_dataset = parse_iadlist(args.iad_dir, "train")
	test_dataset = parse_iadlist(args.iad_dir, "test")

	for i in range(5):

		prefix = FLAGS.prefix+"_train_"+str(i)
		extract_itrs_from_filename_group(train_dataset, i, prefix)
		tf.reset_default_graph()

		prefix = FLAGS.prefix+"_test_"+str(i)
		extract_itrs_from_filename_group(test_dataset, i, prefix)
		tf.reset_default_graph()
		


if __name__ == '__main__':
	if (not os.path.exists(FLAGS.dst_directory)):
		os.makedirs(FLAGS.dst_directory)

	main(FLAGS.iad_dir)