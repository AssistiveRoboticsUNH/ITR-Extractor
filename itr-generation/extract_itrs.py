import tensorflow as tf 
import numpy as np 

from datetime import datetime
import os

import itr_matcher

import argparse
parser = argparse.ArgumentParser(description='Generate IADs from input files')
#required command line args
parser.add_argument('iad_dir', help='The input file')
parser.add_argument('pad_length', help='The length to pad the file')

parser.add_argument('--prefix', nargs='?', type=str, default="complete", help='the prefix to place infront of finished files <prefix>_<layer>.npz')
parser.add_argument('--dst_directory', nargs='?', type=str, default='generated_itrs/', help='where the IADs should be stored')

FLAGS = parser.parse_args()

'''
#0 - empty
#1 - br
#2 - bl
#3 - b
#4 - tr
#5 - r
#6 - tr, bl
#7 - r, bl
#8 - tl
#9 - tl, br
#10 - l
#11 - l, br
#12 - t
#13 - r, tl
#14 - l, tr
#15 - full

CORE_FILTERS_13 = {
		'meets': np.array([[9]]),
		'metBy': np.array([[6]]),
		'starts': np.array([[5,11]]),
		'startedBy': np.array([[5,14]]),
		'finishes': np.array([[7,10]]),
		'finishedBy': np.array([[13,10]]),
		'overlaps': np.array([[13,11]]),
		'overlapedBy': np.array([[7,14]]),
		'during': np.array([[7,11]]),
		'contains': np.array([[13,14]]),
		'before': np.array([[8,1]]),
		'after': np.array([[2,4]]),
		'equals': np.array([[5,10]])
	}
'''

write_file,run_code = 0, 0

############################
# Pairwise Combinations
############################

def pairwise_gather(input_var):
	'''
	Generates a pairwise combination of all the rows in the input tensor
	'''
	num_features = input_var.get_shape()[0]

	# get all unique pairwise combinations of two features
	indices = []
	for i in range(num_features):
		for j in range(i, num_features):
			if(i != j):
				indices.append([[i], [j]])

	print("input_var:", input_var, input_var.get_shape())
	return tf.gather_nd(input_var, indices, name="pairwise_gather")

############################
# Convolution
############################

def permute_filter_combinations(shared_array, array, cur_depth):
	'''
	Recursively get all possible filter combinations of -1 and 1 for a filter shape
	'''
	if(cur_depth == len(array)):
		shared_array.append(array)
	else:
		for value in [-1,1]:
			array[cur_depth] = value
			permute_filter_combinations(shared_array, array[:], cur_depth+1)

def get_variables(filter_width):
	'''
	Generate the fixed filters used in the convolution
	'''
	filters = []
	permute_filter_combinations(filters, [1]*(2*filter_width), 0)
	filters = np.array(filters).reshape((-1, 2, filter_width))

	# modify the shape of the filters to allow convolution by tensorflow
	filters = np.expand_dims(filters, axis = 0)
	filters = np.transpose(filters, (2,3, 0, 1))
	filters = tf.cast(tf.constant(filters),tf.float32)
	return filters

def generate_pairwise_projections(input_ph, filter_width=2):
	'''
	Generate the projection of filters for each of the pairwise combinations
	of rows in the IAD. This involves two steps: 1) the pairwise seprataion 
	of features and 2) the convolution of each pairwise combination with a 
	specific set of fixed filters (known as moments). The best moment at each
	time instance is then projected into a 1-D array for the pairwise combination
		- placeholders: dict, placeholders for the convolution 
				(see get_placeholders function)
		- filter_width: int, default (2) the width of the fixed filters
	'''

	# get pairwise combination of IAD features
	pw = pairwise_gather(input_ph)
	
	# pad the beginning and ending of each IAD with -1 values to ensure that 
	# specific core moments can be found
	pw = tf.pad(pw, tf.constant([[0,0], [0,0], [1,1]]), "CONSTANT", constant_values = -1)
	
	#reshape combinations for subsequent operations
	pw = tf.expand_dims(pw, axis = 0)
	pw = tf.transpose(pw, perm=[1,2,3,0])

	#convolve
	variables = get_variables(filter_width)
	conv0 = tf.nn.conv2d(pw, variables, strides=[1,1,1,1], padding='VALID', name="conv2d_op")
	conv0 = tf.squeeze(conv0, name="squeeze_op", axis=1)

	#collapse data
	return tf.argmax(conv0, axis = 2)

############################
# Collapse and Count
############################

def extract_itrs(projections):
	#global write_file, run_code
	'''
	Identify the IADs present in the pairwise projections generated by the 
	"generate_pairwise_projections" function. This is done by manipulating 
	the data so that it can be passed into a function that runs in C++
		- projections: tensor, a tensor containing the projections for each 
				pairwise combination of features in the IAD
	'''

	# get the properties of the input
	num_pw_combinations = projections.shape[0]
	num_time_instances = projections.shape[1]
	num_itrs = 13

	# write information to file to be read in C++
	projections = projections.astype(np.int64)

	# prepare output array
	itr_counts = [0]*(num_pw_combinations * num_itrs)

	# extract ITRs using C++
	itr_matcher.thread(projections, num_pw_combinations, num_time_instances, itr_counts)

	# reshape the resultant array into a reasonable format
	return np.array(itr_counts).reshape((num_pw_combinations, num_itrs))

############################
# Main
############################

def main(input_dir):
	#provide filenames and generate and save the ITRs into a nump array
	print("opening directory: "+input_dir)

	all_filenames = [f for f in os.listdir(input_dir) if ".npz" in f and "min_max" not in f]
	all_filenames.sort()

	group = []
	for i in range(5):
		group.append([])
	for f in all_filenames:
		print(f, f[-5:-4])
		layer = int(f[-5:-4])
		group[layer].append(f)
	
	for i in range(5):
		data, labels, lengths = [],[],[]
		for filename in group[i]:

			if ".npz" in f:
				f = np.load(os.path.join(input_dir, filename))

				# clip the data for values outside of the expected range
				d = np.clip(f["data"], 0.0, 1.0)

				# scale the data to be between -1 and 1
				d *= 2
				d -= 1

				data.append(d)
				labels.append(f["label"])
				lengths.append(f["length"])

		###############################
		# Extract ITRs
		###############################

		# get the pairwise projection (one dimensional representations of the data)
		print (data.shape)
		ph = tf.placeholder(tf.float32, shape=(data.shape[1],FLAGS.pad_length),name="input_ph")
		itr_extractor = generate_pairwise_projections(ph)

		# prevent TF from consuming entire GPU
		gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.25)

		with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) as sess:
			sess.run(tf.local_variables_initializer())
			sess.run(tf.global_variables_initializer())

			# get the pairwise projection and then extract the ITRs
			itrs = []
			for i in range(len(data)):
				print("Processing file {:6d}/{:6d}".format(i, len(data)))
				iad = np.pad(data[i], [[0,0],[0,FLAGS.pad_length-lengths[i]]], 'constant', constant_value=0)
				pairwise_projections = sess.run(itr_extractor, feed_dict = {ph: iad})
				itrs.append(extract_itrs(pairwise_projections[:, :lengths[i]+1]))

			#stack ITRs and save
			filename = os.path.join(FLAGS.dst_directory, FLAGS.prefix)
			if (os.path.exists(filename+".npz")):
				filename += "_"+datetime.now().strftime("%m-%d-%Y_%H-%M-%S")
			print("saving ITRs together to file: {0}".format(filename))
			np.savez(filename+".npz", data=np.array(itrs), label=labels)

if __name__ == '__main__':
	if (not os.path.exists(FLAGS.dst_directory)):
		os.makedirs(FLAGS.dst_directory)

	main(FLAGS.iad_dir)