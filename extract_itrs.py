import tensorflow as tf 
import numpy as np 
import time, datetime
import os, sys

import scipy.signal

import itr_matcher
from sets import Set

np.set_printoptions(threshold=sys.maxsize) # THIS IS NECESSARY to write the files correctly to disk

import argparse
parser = argparse.ArgumentParser(description='Generate IADs from input files')
#required command line args
parser.add_argument('iad_file', help='The input file')

parser.add_argument('--prefix', nargs='?', type=str, default="complete", help='the prefix to place infront of finished files <prefix>_<layer>.npz')
parser.add_argument('--dst_directory', nargs='?', type=str, default='generated_itrs/', help='where the IADs should be stored')


FLAGS = parser.parse_args()

'''
#0 - empty
#1 - br
#2 - bl
#3 - b
#4 - tr
#5 - r
#6 - tr, bl
#7 - r, bl
#8 - tl
#9 - tl, br
#10 - l
#11 - l, br
#12 - t
#13 - r, tl
#14 - l, tr
#15 - full

CORE_FILTERS_13 = {
		'meets': np.array([[9]]),
		'metBy': np.array([[6]]),
		'starts': np.array([[5,11]]),
		'startedBy': np.array([[5,14]]),
		'finishes': np.array([[7,10]]),
		'finishedBy': np.array([[13,10]]),
		'overlaps': np.array([[13,11]]),
		'overlapedBy': np.array([[7,14]]),
		'during': np.array([[7,11]]),
		'contains': np.array([[13,14]]),
		'before': np.array([[8,1]]),
		'after': np.array([[2,4]]),
		'equals': np.array([[5,10]])
	}
'''

write_file,run_code = 0, 0

############################
# Pairwise Combinations
############################

def pairwise_gather(input_var):
	'''
	Generates a pairwise combination of all the rows in the input tensor
	'''
	num_features = input_var.get_shape()[0]

	# get all unique pairwise combinations of two features
	indices = []
	for i in range(num_features):
		for j in range(i, num_features):
			if(i != j):
				indices.append([[i], [j]])

	return tf.gather_nd(input_var, indices, name="pairwise_gather")

############################
# Convolution
############################

def permute_filter_combinations(shared_array, array, cur_depth):
	'''
	Recursively get all possible filter combinations of -1 and 1 for a filter shape
	'''
	if(cur_depth == len(array)):
		shared_array.append(array)
	else:
		for value in [-1,1]:
			array[cur_depth] = value
			permute_filter_combinations(shared_array, array[:], cur_depth+1)

def get_variables(filter_width):
	'''
	Generate the fixed filters used in the convolution
	'''
	filters = []
	permute_filter_combinations(filters, [1]*(2*filter_width), 0)
	filters = np.array(filters).reshape((-1, 2, filter_width))

	# modify the shape of the filters to allow convolution by tensorflow
	filters = np.expand_dims(filters, axis = 0)
	filters = np.transpose(filters, (2,3, 0, 1))
	filters = tf.cast(tf.constant(filters),tf.float32)
	return filters

def generate_pairwise_projections(input_ph, filter_width=2):
	'''
	Generate the projection of filters for each of the pairwise combinations
	of rows in the IAD. This involves two steps: 1) the pairwise seprataion 
	of features and 2) the convolution of each pairwise combination with a 
	specific set of fixed filters (known as moments). The best moment at each
	time instance is then projected into a 1-D array for the pairwise combination
		- placeholders: dict, placeholders for the convolution 
				(see get_placeholders function)
		- filter_width: int, default (2) the width of the fixed filters
	'''

	# get pairwise combination of IAD features
	pw = pairwise_gather(input_ph)
	
	# pad the beginning and ending of each IAD with -1 values to ensure that 
	# specific core moments can be found
	pw = tf.pad(pw, tf.constant([[0,0], [0,0], [1,1]]), "CONSTANT", constant_values = -1)
	
	#reshape combinations for subsequent operations
	pw = tf.expand_dims(pw, axis = 0)
	pw = tf.transpose(pw, perm=[1,2,3,0])

	#convolve
	variables = get_variables(filter_width)
	conv0 = tf.nn.conv2d(pw, variables, strides=[1,1,1,1], padding='VALID', name="conv2d_op")
	conv0 = tf.squeeze(conv0, name="squeeze_op", axis=1)

	#collapse data
	return tf.argmax(conv0, axis = 2)

############################
# Collapse and Count
############################

def extract_itrs(projections):
	#global write_file, run_code
	'''
	Identify the IADs present in the pairwise projections generated by the 
	"generate_pairwise_projections" function. This is done by manipulating 
	the data so that it can be passed into a function that runs in C++
		- projections: tensor, a tensor containing the projections for each 
				pairwise combination of features in the IAD
	'''

	# get the properties of the input
	num_pw_combinations = projections.shape[0]
	num_time_instances = projections.shape[1]
	num_itrs = 13

	# write information to file to be read in C++
	projections = projections.astype(np.int64)

	# prepare output array
	itr_counts = [0]*(num_pw_combinations * num_itrs)

	# extract ITRs using C++
	itr_matcher.thread(projections, num_pw_combinations, num_time_instances, itr_counts)

	# reshape the resultant array into a reasonable format
	return np.array(itr_counts).reshape((num_pw_combinations, num_itrs))

############################
# Main
############################

def main(input_filename):
	#provide filenames and generate and save the ITRs into a nump array
	
	f = np.load(input_filename)
	data, labels, lengths = f["data"], f["label"], f["length"]
	
	# clip the data for values outside of the expected range
	data = np.clip(data, 0.0, 1.0)

	# scale the data to be between -1 and 1
	data *= 2
	data -= 1

	###############################
	# Extract ITRs
	###############################

	# get the pairwise projection (one dimensional representations of the data)
	ph = tf.placeholder(tf.float32, shape=(data.shape[1],data.shape[2]),name="input_ph")
	itr_extractor = generate_pairwise_projections(ph)

	# prevent TF from consuming entire GPU
	gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=0.25)

	with tf.Session(config=tf.ConfigProto(gpu_options=gpu_options)) as sess:
		sess.run(tf.local_variables_initializer())
		sess.run(tf.global_variables_initializer())

		# get the pairwise projection and then extract the ITRs
		itrs = []
		for i in range(len(data)):
			print("Processing file {:6d}/{:6d}".format(i, len(data)))
			pairwise_projections = sess.run(itr_extractor, feed_dict = {ph: data[i]})
			itrs.append(extract_itrs(pairwise_projections[:, :lengths[i]+1]))

		#stack ITRs and save
		print("saving ITRs together:")
		filename = os.path.join(FLAGS.dst_directory, FLAGS.prefix)+".npz"
		np.savez(filename, data=np.array(itrs), label=labels)

if __name__ == '__main__':
	if (not os.path.exists(FLAGS.dst_directory)):
		os.makedirs(FLAGS.dst_directory)

	main(FLAGS.iad_file)
